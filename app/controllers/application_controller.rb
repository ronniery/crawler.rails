# frozen_string_literal: true

require 'jwtoken'

# ApplicationController
#
# The base controller of this app, that will filter the requests preventing that untokened users
# access the api endpoints, checking if they're present on header or on url (path) and if the given
# tokens are valid (by jwt decode process), if the response to this questions are true the request
# will be handled for the requested controller or will be unauthorized for this controller.
#
class ApplicationController < ActionController::Base
  # Handles the exceptions generated by JWT
  include ExceptionHandler
  # Check before every request if the token is present
  before_action :check_auth

  # Checks if the request has token on header or on path and if the token is valid (jwt handles that)
  # and if there isn't any token (url or header) the default message with unauthorized status will be
  # send as response
  def check_auth
    unless (token_present? || token_on_path?) && valid_token?
      render json: {
        message: 'You need request a token before go ahead.',
        status: 401
      }, status: :unauthorized
    end
  end

  private

  # Check if a valid token was generated with the jwt decode process
  def valid_token?
    !JWToken.decode(token).blank?
  end

  # Check if the t={token} exists on the url
  def token_on_path?
    !params[:t].blank?
  end

  # Check if the authorization header with Bearer {token} is present on header collection
  def token_present?
    auth_header = request.env.fetch 'HTTP_AUTHORIZATION', ''
    !auth_header.scan(/Bearer/).flatten.first.blank?
  end

  # Get the value of token in header or path
  def token
    if token_present?
      request.env['HTTP_AUTHORIZATION'].scan(/Bearer (.*)$/).flatten.last
    else
      params[:t]
    end
  end
end
